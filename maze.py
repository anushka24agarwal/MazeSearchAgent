__author__ = "ANUSHKA AGARWAL"
__email__ = "aa5477@columbia.edu"

#======================================================================#
#*#*#*# Optional: Import any allowed libraries you may need here #*#*#*#
#======================================================================#
import queue
from queue import LifoQueue
from queue import PriorityQueue
import time
import resource
#=================================#
#*#*#*# Your code ends here #*#*#*#
#=================================#

import argparse

if __name__ == "__main__":
	parser = argparse.ArgumentParser(description='Robot Path Planning | HW 1 | COMS 4701')
	parser.add_argument('-bfs', action="store_true", default=False , help="Run BFS on the map")
	parser.add_argument('-dfs', action="store_true", default=False, help= "Run DFS on the map")
	parser.add_argument('-astar', action="store_true", default=False, help="Run A* on the map")
	parser.add_argument('-ida', action="store_true", default=False, help="Run Iterative Deepening A* on the map")
	parser.add_argument('-all', action="store_true", default=False, help="Run all the 4 algorithms")
	parser.add_argument('-m', action="store", help="Map filename")
	results = parser.parse_args()
	
	if results.m=="" or not(results.all or results.astar or results.bfs or results.dfs or results.ida):
		print("Check the parameters : >> python hw1_UNI.py -h")
		exit()
	
	if results.all:
		results.bfs = results.dfs = results.astar = results.ida = True

	# Reading of map given and all other initializations
	try:
		with open(results.m) as f:
			arena = f.read()
			arena = arena.split("\n")
	except:
		print("Error in reading the arena file.")
		exit()

	# Internal representation
	print(arena)

	print("The arena of size "+ str(len(arena)) + "x" + str(len(arena[0])))
	print("\n".join(arena))

class MazeState:
	'''
	This class is an abstraction to store a maze state, which contains the following:
	- Maze configuration (arena)
	- Current Position (position in the the maze that the current state represents)
	- Parent (the state from which the current state came from)
	- Action (the action taken in the parent state, direction moved, which lead to the creation of the current state)
	- Cost (Cost  of the path taken from the start to the current state)
	- Children (a child of the current state is generated by moving in a direction)
	'''

	'''
	Returns the start index of the maze based on the given arena
	returns (-1, -1) if no start index found
	'''
	def get_start_index(self):
		for i in range(len(self.arena)):
			for j in range(len(self.arena[0])):
				if self.arena[i][j] == 's':
					return (i, j)
		return None

	'''
	Returns the goal index of the maze based on the given arena
	returns (-1, -1) if no goal index found
	'''

	def get_goal_index(self):
		for i in range(len(self.arena)):
			for j in range(len(self.arena[0])):
				if self.arena[i][j] == 'g':
					return (i, j)
		return None
		

	def __init__(self, arena, parent=None, action='Start', cost=0, current_position=(-1,-1)):

		self.arena = arena
		self.parent = parent
		self.action = action
		self.cost = cost
		self.children = []

		self.start = self.get_start_index()
		self.goal = self.get_goal_index()

		if(current_position[0] == -1):
			self.current_position = self.start
		else:
			self.current_position = current_position

	def display(self):
		print("\n".join(self.arena))

	def move_up(self):
		'''
		This function checks if up is a valid move from the given state.
		If up is a valid move, returns a child in which the player has moved up
		Else returns None.
		'''
		#=================================================================#
		#*#*#*# TODO: Write your code to move up in the puzzle here #*#*#*#
		#=================================================================#
		x, y = self.current_position
		if x > 0 and self.arena[x-1][y] != 'o':
			new_position = (x-1, y)
			return MazeState(self.arena, parent=self, action='Up', cost=self.cost + 1, current_position=new_position)
		return None
		#=================================#
		#*#*#*# Your code ends here #*#*#*#
		#=================================#


	def move_down(self):
		'''
		This function checks if down is a valid move from the given state.
		If down is a valid move, returns a child in which the player has moved down.
		Else returns None.
		'''
		#===================================================================#
		#*#*#*# TODO: Write your code to move down in the puzzle here #*#*#*#
		#===================================================================#
		x, y = self.current_position
		if x < len(self.arena)-1 and self.arena[x+1][y] != 'o':
			new_position = (x + 1, y)
			return MazeState(self.arena, parent=self, action='Down', cost=self.cost + 1, current_position=new_position)
		return None
		#=================================#
		#*#*#*# Your code ends here #*#*#*#
		#=================================#

	def move_left(self):
		'''
		This function checks if left is a valid move from the given state.
		If left is a valid move, returns a child in which the player has moved left.
		Else returns None.
		'''
		#===================================================================#
		#*#*#*# TODO: Write your code to move left in the puzzle here #*#*#*#
		#===================================================================#
		x, y = self.current_position
		if y > 0 and self.arena[x][y-1] != 'o':
			new_position = (x, y-1)
			return MazeState(self.arena, parent=self, action='Left', cost=self.cost + 1, current_position=new_position)
		return None
		#=================================#
		#*#*#*# Your code ends here #*#*#*#
		#=================================#


	def move_right(self):
		'''
		This function checks if right is a valid move from the given state.
		If left is a valid move, returns a child in which the player has moved left.
		Else returns None.
		'''
		#====================================================================#
		#*#*#*# TODO: Write your code to move right in the puzzle here #*#*#*#
		#====================================================================#
		x, y = self.current_position
		if y < len(self.arena[0]) - 1 and self.arena[x][y+1] != 'o':
			new_position = (x, y+1)
			return MazeState(self.arena, parent=self, action='Right', cost=self.cost + 1, current_position=new_position)
		return None
		#=================================#
		#*#*#*# Your code ends here #*#*#*#
		#=================================#

	def expand(self):
		"""
		Generate the child nodes of this node
		"""

		if(len(self.children) != 0):
			return self.children

		# Do not change the order in this function, since the grading script assumes this order of expansion when checking
		children = [self.move_up(), self.move_right(), self.move_down(), self.move_left()]

		self.children = [state for state in children if state is not None]

		return self.children

	def __hash__(self):
		'''
		Maze states hashed based on cost.
		This function may be modified if required.
		'''
		#============================================================================================#
		#*#*#*# Optional: May be modified if your algorithm requires a different hash function #*#*#*#
		#============================================================================================#

		return self.cost

		#=================================#
		#*#*#*# Your code ends here #*#*#*#
		#=================================#

	# def __eq__(self, other):
	# 	'''
	# 	Maze states are defined as equal if they have the same dimensions and the same current position.
	# 	This function may be modified if required.
	# 	'''

	# 	#=============================================================================================#
	# 	#*#*#*# Optional: May be modified if your algorithm requires a different equality check #*#*#*#
	# 	#=============================================================================================#

	# 	m1 = self.arena
	# 	m2 = other.arena

	# 	if(len(m1) != len(m2)):
	# 		return False

	# 	for i in range(0, len(m1)):
	# 		if(not (m1[i] == m2[i])):
	# 			return False

	# 	return self.current_position == other.current_position

		#=================================#
		#*#*#*# Your code ends here #*#*#*#
		#=================================#

	#=====================================================================================#
	#*#*#*# Optional: Write any other functions you may need in the MazeState Class #*#*#*#
	#=====================================================================================#

	def __lt__(self,other):
		return(self.cost<other.cost)

	def get_path(self):
		path=[]
		current=self
		while current.parent is not None:
			path.append(current.current_position)
			current=current.parent
		path.reverse()
		return path

	#=================================#
	#*#*#*# Your code ends here #*#*#*#
	#=================================#

#================================================================================#
#*#*#*# Optional: You may write helper functions in this space if required #*#*#*#
#================================================================================#

def manhattan_distance(pos1, pos2):
    """
    Calculate the Manhattan distance between two points (pos1 and pos2).
    """
    return abs(pos1[0] - pos2[0]) + abs(pos1[1] - pos2[1])

def depth_search(state, threshold, path, nodes_expanded, max_nodes_stored, current_path):
	f = state.cost + manhattan_distance(state.current_position, state.goal)

	if f > threshold:
		return f  # Return the next threshold
	if state.current_position == state.goal:
		path.append(state.current_position)  # Mark the path if goal is reached
		return "FOUND"  # Found the goal

	nodes_expanded[0] += 1
	min_threshold = float('inf')
	current_path.append(state)
	max_nodes_stored[0] = max(max_nodes_stored[0],len(current_path))

	for child in state.expand():
		result = depth_search(child, threshold, path, nodes_expanded, max_nodes_stored, current_path)
		if result == "FOUND":
			path.append(state.current_position)
			return "FOUND"
		if result < min_threshold:
			min_threshold = result
	
	current_path.pop()
	return min_threshold

def mark_path(arena, path):
	for x,y in path:
		if(arena[x][y]!='g' and arena[x][y]!='s'):
			arena[x] = arena[x][:y] + '*' + arena[x][y+1:]

#=================================#
#*#*#*# Your code ends here #*#*#*#
#=================================#


'''
This function runs Breadth First Search on the input arena (which is a list of str)
Returns a ([], int) tuple where the [] represents the solved arena as a list of str and the int represents the cost of the solution
'''
def bfs(arena):

	#=================================================#
	#*#*#*# TODO: Write your BFS algorithm here #*#*#*#
	#=================================================#
	start_time= time.time()
	bfs_start_ram = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss

	start_state=MazeState(arena)
	start=start_state.start
	goal=start_state.goal
	
	if start is None or goal is None:
		print("Start or goal position not found.")
		return [], -1, -1, -1, -1, -1, -1

	# BFS setup
	frontier = queue.Queue()  # Queue for BFS
	frontier.put(start_state)
	explored = set()  # To track explored nodes
	explored.add(start)

	nodes_expanded = 0
	max_nodes_stored = 1
	max_search_depth = 0
	cost=0

	while not frontier.empty():
		current_state = frontier.get()
		
		# If goal is reached
		if current_state.current_position == goal:
			path = current_state.get_path()
			cost=len(path)
			for x,y in path:
				if(arena[x][y]!='g'):
					arena[x]=arena[x][:y]+'*'+arena[x][y+1:]

			# End time and RAM usage
			end_time = time.time()
			bfs_time = end_time - start_time
			bfs_ram = (resource.getrusage(resource.RUSAGE_SELF).ru_maxrss - bfs_start_ram)/(2**10) # RAM usage in KB

			return arena, cost, nodes_expanded, max_nodes_stored, max_search_depth, bfs_time, bfs_ram

		# Expand the current node
		nodes_expanded+=1
		for child in current_state.expand():
			if child.current_position not in explored:
				frontier.put(child)
				explored.add(child.current_position)

				max_search_depth = max(max_search_depth, child.cost)
		max_nodes_stored = len(explored)

	# If no path is found
	print("No path found")
	end_time = time.time()
	bfs_time = end_time - start_time
	bfs_ram = (resource.getrusage(resource.RUSAGE_SELF).ru_maxrss - bfs_start_ram)/(2**10)

	return arena, -1, nodes_expanded, max_nodes_stored, max_search_depth, bfs_time, bfs_ram # Replace with return values
	#=================================#
	#*#*#*# Your code ends here #*#*#*#
	#=================================#

'''
This function runs Depth First Search on the input arena (which is a list of str)
Returns a ([], int) tuple where the [] represents the solved arena as a list of str and the int represents the cost of the solution
'''
def dfs(arena):

    #=================================================#
	#*#*#*# TODO: Write your DFS algorithm here #*#*#*#
	#=================================================#

	start_time= time.time()
	dfs_start_ram = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss

	start_state=MazeState(arena)
	start=start_state.start
	goal=start_state.goal

	if start is None or goal is None:
		print("Start or goal position not found.")
		return [], -1, -1, -1, -1, -1, -1

	frontier=LifoQueue()
	frontier.put(start_state)
	explored=set()
	explored.add(start)

	nodes_expanded = 0
	max_nodes_stored = 1
	max_search_depth = 0
	parent = {}


	# Perform the DFS
	while not frontier.empty():
		current_state = frontier.get()

		# If goal is reached
		if current_state.current_position == goal:
			path = current_state.get_path()
			cost=len(path)
			for x,y in path:
				if(arena[x][y]!='g'):
					arena[x]=arena[x][:y]+'*'+arena[x][y+1:]

		# End time and RAM usage
			end_time = time.time()
			dfs_time = end_time - start_time
			dfs_ram = (resource.getrusage(resource.RUSAGE_SELF).ru_maxrss - dfs_start_ram)/(2**10) # RAM usage in KB
			max_nodes_stored = len(explored)
			return arena, cost, nodes_expanded, max_nodes_stored, max_search_depth, dfs_time, dfs_ram

		# Expand the current node and process its children
		nodes_expanded+=1
		for child in reversed(current_state.expand()):
			if child.current_position not in explored:
				frontier.put(child)  # Add the child to the stack (LIFO behavior)
				explored.add(child.current_position)  # Mark the child as explored
				parent[child] = current_state  # Record the parent node
				max_search_depth = max(max_search_depth, child.cost)

	# If no path is found
	print("No path found")
	end_time = time.time()
	dfs_time = end_time - start_time
	dfs_ram = (resource.getrusage(resource.RUSAGE_SELF).ru_maxrss - dfs_start_ram)/(2**10)
	return arena, -1, nodes_expanded, max_nodes_stored, max_search_depth, dfs_time, dfs_ram # Replace with return values
	#=================================#
	#*#*#*# Your code ends here #*#*#*#
	#=================================#

'''
This function runs A* Search on the input arena (which is a list of str)
Returns a ([], int) tuple where the [] represents the solved arena as a list of str and the int represents the cost of the solution
'''
def astar(arena):

	#================================================#
	#*#*#*# TODO: Write your A* algorithm here #*#*#*#
	#================================================#

	start_state=MazeState(arena)
	start=start_state.start
	goal=start_state.goal

	start_time= time.time()
	astar_start_ram = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss

	if start is None or goal is None:
		print("Start or goal position not found.")
		return [], -1, -1, -1, -1, -1, -1

	frontier= PriorityQueue()
	frontier.put((0,start_state))
	explored=set()
	explored.add(start)

	nodes_expanded = 0
	max_nodes_stored = 1
	max_search_depth = 0
	parent = {}
	parent[start_state]=None

	while not frontier.empty():
		_, current_state = frontier.get()
		current_position=current_state.current_position

		# If goal is reached
		if current_position == goal:
			arena=[list(row) for row in arena]
			path=current_state.get_path()
			cost=len(path)
			for x,y in path:
				if(arena[x][y]!='g'):
					arena[x][y]='*'
			# Convert back to list of strings
			arena = ["".join(row) for row in arena]
		
		# End time and RAM usage
			end_time = time.time()
			astar_time = end_time - start_time
			astar_ram = (resource.getrusage(resource.RUSAGE_SELF).ru_maxrss - astar_start_ram)/(2**10) # RAM usage in KB
			max_nodes_stored = len(explored)
			return arena, cost, nodes_expanded, max_nodes_stored, max_search_depth, astar_time, astar_ram

		# Expand the current node
		nodes_expanded+=1
		for child in current_state.expand():
			child_pos = child.current_position

			if child_pos not in explored:
				explored.add(child_pos)
				parent[child] = current_state
				g = child.cost
				h = manhattan_distance(child_pos, goal)
				f = g + h
				frontier.put((f,child))

				max_search_depth = max(max_search_depth, child.cost)

	# If no path is found
	print("No path found")
	end_time = time.time()
	astar_time = end_time - start_time
	astar_ram = (resource.getrusage(resource.RUSAGE_SELF).ru_maxrss - astar_start_ram)/(2**10)
	return arena, -1, nodes_expanded, max_nodes_stored, max_search_depth, dfs_time, dfs_ram # Replace with return values
	#=================================#
	#*#*#*# Your code ends here #*#*#*#
	#=================================#

'''
This function runs Iterative Deepening A* Search on the input arena (which is a list of str)
Returns a ([], int) tuple where the [] represents the solved arena as a list of str and the int represents the cost of the solution
'''
def ida(arena):

	#=================================================#
	#*#*#*# TODO: Write your IDA algorithm here #*#*#*#
	#=================================================#
	start_time= time.time()
	ida_start_ram = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss

	start_state=MazeState(arena)
	start=start_state.start
	goal=start_state.goal

	if start is None or goal is None:
		print("Start or goal position not found.")
		return [], -1, -1, -1, -1, -1, -1

	last_item=manhattan_distance(start,goal)
	path=[]

	nodes_expanded = [0]
	max_nodes_stored = [0]
	max_search_depth = 0
	current_path=[]

	while True:
		temp = depth_search(start_state, last_item, path, nodes_expanded, max_nodes_stored, current_path)
		if temp == "FOUND":  # Found a solution
			mark_path(arena,path)
			end_time = time.time()
			ida_time = end_time - start_time
			ida_ram = (resource.getrusage(resource.RUSAGE_SELF).ru_maxrss - ida_start_ram)/(2**10)
			max_search_depth = len(path)-1
			return arena, len(path)-1, nodes_expanded[0], max_nodes_stored[0], max_search_depth, ida_time, ida_ram

		if temp == float('inf'):
			return arena, -1, nodes_expanded[0], max_nodes_stored[0], 0, 0, 0

		last_item=temp
	
	# If no path is found
	print("No path found")
	end_time = time.time()
	astar_time = end_time - start_time
	astar_ram = (resource.getrusage(resource.RUSAGE_SELF).ru_maxrss - astar_start_ram)/(2**10)
	return arena, -1, nodes_expanded, max_nodes_stored, max_search_depth, dfs_time, dfs_ram

	#=================================#
	#*#*#*# Your code ends here #*#*#*#
	#=================================#

if __name__ == "__main__":
	if results.bfs:
		print("\nBFS algorithm called")
		bfs_arena, bfs_cost, bfs_nodes_expanded, bfs_max_nodes_stored, bfs_max_search_depth, bfs_time, bfs_ram = bfs(arena)
		print("\n".join(bfs_arena))
		print("BFS:")
		print("Cost: " + str(bfs_cost))
		print("Nodes Expanded: " + str(bfs_nodes_expanded))
		print("Max Nodes Stored: " + str(bfs_max_nodes_stored))
		print("Max Search Depth: " + str(bfs_max_search_depth))
		print("Time: " + str(bfs_time) + "s")
		print("RAM Usage: " + str(bfs_ram) + "kB\n")

	if results.dfs:
		print("\nDFS algorithm called")
		dfs_arena, dfs_cost, dfs_nodes_expanded, dfs_max_nodes_stored, dfs_max_search_depth, dfs_time, dfs_ram = dfs(arena)
		print("\n".join(dfs_arena))
		print("DFS:")
		print("Cost: " + str(dfs_cost))
		print("Nodes Expanded: " + str(dfs_nodes_expanded))
		print("Max Nodes Stored: " + str(dfs_max_nodes_stored))
		print("Max Search Depth: " + str(dfs_max_search_depth))
		print("Time: " + str(dfs_time) + "s")
		print("RAM Usage: " + str(dfs_ram) + "kB\n")

	if results.astar:
		print("\nA* algorithm called")
		astar_arena, astar_cost, astar_nodes_expanded, astar_max_nodes_stored, astar_max_search_depth, astar_time, astar_ram = astar(arena)
		print("\n".join(astar_arena))
		print("A*:")
		print("Cost: " + str(astar_cost))
		print("Nodes Expanded: " + str(astar_nodes_expanded))
		print("Max Nodes Stored: " + str(astar_max_nodes_stored))
		print("Max Search Depth: " + str(astar_max_search_depth))
		print("Time: " + str(astar_time) + "s")
		print("RAM Usage: " + str(astar_ram) + "kB\n")

	if results.ida:
		print("\nIterative Deepening A* algorithm called")
		ida_arena, ida_cost, ida_nodes_expanded, ida_max_nodes_stored, ida_max_search_depth, ida_time, ida_ram = ida(arena)
		print("\n".join(ida_arena))
		print("Iterative Deepening A*:")
		print("Cost: " + str(ida_cost))
		print("Nodes Expanded: " + str(ida_nodes_expanded))
		print("Max Nodes Stored: " + str(ida_max_nodes_stored))
		print("Max Search Depth: " + str(ida_max_search_depth))
		print("Time: " + str(ida_time) + "s")
		print("RAM Usage: " + str(ida_ram) + "kB\n")


